# 상영 중인 영화를 조회하는 쿼리 : 영화 제목, 개봉일 
SELECT MV_TITLE 영화, MV_DATE 개봉일 FROM MOVIE WHERE MV_STATE = '상영중'; 


# CGV 강남을 선택하고, 미키17을 선택했을 때 상영 가능한 날짜를 조회하는 쿼리
SELECT * FROM SCHEDULE JOIN MOVIE ON SD_MV_NUM = MV_NUM JOIN SCREEN ON SD_SC_NUM = SC_NUM JOIN THEATER ON SC_TT_NUM = TT_NUM WHERE MV_TITLE = '미키17' AND TT_NAME = 'CGV강남';
SELECT SD_DATE FROM SCHEDULE JOIN MOVIE ON SD_MV_NUM = MV_NUM JOIN SCREEN ON SD_SC_NUM = SC_NUM JOIN THEATER ON SC_TT_NUM = TT_NUM WHERE MV_TITLE = '미키17' AND TT_NAME = 'CGV강남';

-- 강사님 ->
-- 웹에서 할때는 클릭클릭으로 넘어가니 그냥 기본키 넘겨주면 됨 
SELECT * FROM SCHEDULE WHERE SD_MV_NUM = 1;
-- CGV강남(1) 선택, 미키17(1) 선택 
SELECT DISTINCT SC_DATE FROM SCHEDULE JOIN SCREEN ON SC_NUM = SD_SC_NUM WHERE SD_MV_NUM = 1 AND SC_TT_NUM = 1;
-- SELECT ALL 하면 영화관하고 영화제목을 모르니 JOIN 해줘서
SELECT DISTINCT * FROM SCHEDULE 
JOIN SCREEN ON SC_NUM = SD_SC_NUM 
JOIN THEATER ON TT_NUM = SC_TT_NUM
JOIN MOVIE ON MV_NUM = SD_MV_NUM
WHERE MV_TITLE = "미키17" AND TT_NAME = "CGV강남";


# CGV강남 1관의 등록된 좌석을 조회하는 쿼리
SELECT * FROM SEAT JOIN SCREEN ON SE_SC_NUM = SC_NUM JOIN THEATER ON SC_TT_NUM = TT_NUM WHERE TT_NAME = "CGV강남" AND SC_NUM = 1;

SELECT SE_NAME FROM SEAT
JOIN SCREEN ON SC_NUM = SE_SC_NUM
JOIN THEATER ON TT_NUM = SC_TT_NUM
WHERE SC_NAME = "1관" AND TT_NAME = "CGV강남" AND SE_POS = "Y";

# 단순하게 -> CGV강남 1관(1)의 3월 11일 16:20:00 미키17(3)의 좌석을 조회 
SELECT SE_NAME FROM SEAT
WHERE SE_SC_NUM = 1 AND SE_POS = "Y";
-- ->
SELECT SE_NAME FROM SEAT
JOIN SCHEDULE ON SD_SC_NUM = SE_SC_NUM
WHERE /*SE_SC_NUM = 1 AND */SE_POS = "Y" AND SD_NUM = 3;


# CGV강남 1관의 3월 11일 16:20에 상영하는 미키17의 예약 가능한 좌석을 조회하는 쿼리 -> 예매 여부 : 예매 리스트와 JOIN해서 예매가 안 된 좌석을 조회
# CGV강남 1관의 3월 11일 16:20에 상영하는 미키17를 조회하는 쿼리
SELECT SE_NAME FROM SEAT JOIN SCREEN ON SE_SC_NUM = SC_NUM JOIN THEATER ON SC_TT_NUM = TT_NUM RIGHT JOIN SCHEDULE ON SC_NUM = SD_SC_NUM  JOIN MOVIE ON SD_MV_NUM = MV_NUM WHERE TT_NAME = "CGV강남" AND SC_NUM = 1 AND SD_DATE = "2025-03-11" AND MV_TITLE = "미키17";
-- 내가한거

 -- 예매 리스트에는 좌석 번호만 있고 언제 무슨 영환지에 대한 정보가 X -> 티켓과 조인해야
-- 내가한거 
SELECT * FROM SEAT JOIN SCREEN ON SE_SC_NUM = SC_NUM JOIN THEATER ON SC_TT_NUM = TT_NUM RIGHT JOIN SCHEDULE ON SC_NUM = SD_SC_NUM  JOIN MOVIE ON SD_MV_NUM = MV_NUM LEFT JOIN TICKET_LIST ON SE_NUM = TL_SE_NUM WHERE TT_NAME = "CGV강남" AND SC_NUM = 1 AND SD_DATE = "2025-03-11" AND MV_TITLE = "미키17" AND TL_NUM IS NULL ;

SELECT SE_NAME FROM SEAT
JOIN SCHEDULE ON SD_SC_NUM = SE_SC_NUM
-- LEFT JOIN TICKET ON TI_SD_NUM = SD_NUM
LEFT JOIN TICKET_LIST ON SE_NUM = TL_SE_NUM  -- 이렇게 하면 TICKET 연결 안해도 됨 
WHERE SE_POS = "Y" AND SD_NUM = 3 AND TL_SE_NUM IS NULL;	-- NULL을 찾을 때는 속성 = NULL 로 하면 안되고 속성 IS NULL로 해야 함... 

# 2번 스케줄에서 예약된 좌석들
SELECT SEAT.* FROM SEAT 
	JOIN SCHEDULE ON SD_SC_NUM =SE_SC_NUM 
    LEFT JOIN TICKET ON TI_SD_NUM = SD_NUM 
    LEFT JOIN TICKET_LIST ON TI_NUM = TL_TI_NUM 
    WHERE SE_POS = "Y" AND SD_NUM = 2 AND TL_SE_NUM = SE_NUM AND TI_STATE = '결제';

# CGV강남 4관 3월 11일 19:10 상영 미키17 예약가능 좌석 조회 쿼리 
# 예매 리스트와 JOIN 해서 예매가 안 된 좌석 조회(NOT IN 으로)
SELECT SE_NAME FROM SEAT
WHERE SE_SC_NUM = 4 AND SE_NUM NOT IN( 
	SELECT SE_NUM FROM SEAT 
    JOIN SCHEDULE ON SD_SC_NUM = SE_SC_NUM
	LEFT JOIN TICKET ON TI_SD_NUM = SD_NUM
	LEFT JOIN TICKET_LIST ON TI_NUM = TL_TI_NUM
	WHERE SE_POS = "Y" AND SD_NUM = 2 AND TI_STATE = '결제' AND TL_SE_NUM = SE_NUM); -- 취소 된 A3 A4 돌아옴 

# 장르별 등록된 영화수를 조회하는 쿼리 
SELECT GR_NAME, COUNT(MG_GR_NAME) 영화수 FROM GENRE 	-- COUNT(*)  하면 NULL 포함하는 모든 칼럼 세기때문에 COUNT(칼럼 이름) 
LEFT JOIN MOVIE_GENRE ON GR_NAME = MG_GR_NAME	-- 그냥 JOIN 하면 등록안된 장르들은 조회 X
GROUP BY GR_NAME; 									-- COUNT : 같은 값을 가진 행들을 묶음. COUNT,SUM,AVG,MAX,MIN과 같이 -> HAVING 은 GROUPBY 조건(단, WHERE랑 다른건 그룹화 이후에 적용) COUNT(*) AS 개수 하고 GROUP BY 하고 HAVING 개수 >= 2 이런식으로 쓸수 있단 말

# 현재 시간 기준 한달 사이 개봉한 영화 조회하는 쿼리
SELECT * FROM MOVIE
WHERE MV_DATE BETWEEN DATE_SUB(NOW(), INTERVAL 1 MONTH) AND NOW();

/*
SELECT * FROM MOVIE
WHERE MV_DATE >= DATE_SUB(NOW(), INTERVAL 1 MONTH);	-- 얘도 되긴함 
*/

# 각 영화별 예매수를 조회 
# 예매수는 상영시간이 지나지 않은 예매만 해당 

SELECT * FROM MOVIE 
JOIN SCHEDULE ON SD_MV_NUM = MV_NUM 
JOIN TICKET ON SD_NUM = TI_SD_NUM
JOIN TICKET_LIST ON TI_NUM = TL_TI_NUM
-- WHERE TI_STATE = '결제'
;

SELECT DISTINCT MV_TITLE, COUNT(TI_ME_NUM) FROM MOVIE 
JOIN SCHEDULE ON SD_MV_NUM = MV_NUM 
JOIN TICKET ON SD_NUM = TI_SD_NUM
JOIN TICKET_LIST ON TI_NUM = TL_TI_NUM
WHERE TI_STATE = '결제'
GROUP BY MV_NUM;

-- 강사님
SELECT MOVIE.*, SUM(TI_TEEN + TI_ADULT) FROM MOVIE 
LEFT JOIN SCHEDULE ON SD_MV_NUM = MV_NUM 
LEFT JOIN TICKET ON SD_NUM = TI_SD_NUM
-- WHERE TI_STATE = '결제' AND SD_DATE >= NOW()
WHERE TI_STATE = '결제' AND CONCAT(SD_DATE," ",SD_TIME) >= NOW()
GROUP BY MV_NUM;

# 각 영화별 예매수를 조회하여 예매가 높은 순으로 조회하는 쿼리 
SELECT RANK() OVER(ORDER BY T.예매수 DESC) 순위, T.*
FROM ( 
SELECT MOVIE.*, SUM(TI_TEEN + TI_ADULT) 예매수 FROM MOVIE
LEFT JOIN SCHEDULE ON SD_MV_NUM = MV_NUM 
LEFT JOIN TICKET ON SD_NUM = TI_SD_NUM
WHERE TI_STATE = '결제' AND CONCAT(SD_DATE," ",SD_TIME) >= NOW()
GROUP BY MV_NUM
ORDER BY 예매수 DESC) AS T;


# 각 영화별 예매수를 조회하여 예매율을 조회하는 쿼리 => 예매율 = 영화예매수 / 전체 영화 예매수 * 100

SELECT MOVIE.*, SUM(TI_TEEN + TI_ADULT) 예매수, SUM(TI_TEEN + TI_ADULT) * 100 / SUM(SUM(TI_TEEN + TI_ADULT)) OVER() AS 예매율		-- SUM() OVER() 하면 GROUP BY로 묶인 내부를 한번더(집계함수의 집계 결과를 한번더 계산하기 위해 OVER() 추가 필수) 
FROM MOVIE
LEFT JOIN SCHEDULE ON SD_MV_NUM = MV_NUM 
LEFT JOIN TICKET ON SD_NUM = TI_SD_NUM
WHERE TI_STATE = '결제' AND CONCAT(SD_DATE," ",SD_TIME) >= NOW()
GROUP BY MV_NUM
ORDER BY 예매수 DESC;									
			
											 -- 서브쿼리 이용해서
# GROUP BY 할때 사용하지 않은 속성 조회하는 경우 에러 해결하는 쿼리(실행하고 인스턴스 나갔다 들어와야 적용됨)
SET GLOBAL sql_mode = 'STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION';	
SELECT M.*, SUM(예매수) * 100 / SUM(예매수) AS 예매율 FROM (                                        
	SELECT MOVIE.*, SUM(TI_TEEN + TI_ADULT) 예매수
		FROM MOVIE 
		LEFT JOIN SCHEDULE ON SD_MV_NUM = MV_NUM 
		LEFT JOIN TICKET ON SD_NUM = TI_SD_NUM
		WHERE TI_STATE = '결제' AND CONCAT(SD_DATE," ",SD_TIME) >= NOW()
		GROUP BY MV_NUM) M;									
# 원상 복구하는 쿼리
SET GLOBAL sql_mode = 'STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION,ONLY_FULL_GROUP_BY';	
	
                                                        
# 예매율 순으로 순위를 조회하는 쿼리
-- SELECT RANK() OVER(ORDER BY T.예매율 DESC) 순위, T.*
SELECT RANK() OVER(ORDER BY 예매율 DESC) AS 순위, T.*
FROM ( 
SELECT MOVIE.*, SUM(TI_TEEN + TI_ADULT) 예매수, SUM(TI_TEEN + TI_ADULT) * 100 / SUM(SUM(TI_TEEN + TI_ADULT)) OVER() AS 예매율
FROM MOVIE
LEFT JOIN SCHEDULE ON SD_MV_NUM = MV_NUM 
LEFT JOIN TICKET ON SD_NUM = TI_SD_NUM
WHERE TI_STATE = '결제' AND CONCAT(SD_DATE," ",SD_TIME) >= NOW()
GROUP BY MV_NUM
-- ORDER BY 예매수 DESC	-- 여기선 필요없음(랭크오버 하기때문)
) AS T;		 


# 영화를 등록순으로 10개 조회하는 쿼리  --> 등록순으로 기본키 지정되기때문에 따로 지정할 필요 X 
SELECT * FROM MOVIE LIMIT 10;

# 본준호 감독이 참여한 모든 영화를 조회하는 쿼리 
SELECT * FROM PERSON 
JOIN ACTOR ON AT_PR_NUM = PR_NUM
JOIN MOVIE_ACTOR ON MA_AT_NUM = AT_NUM
JOIN MOVIE ON MA_MV_NUM = MV_NUM
WHERE PR_NAME = "봉준호" AND AT_POSITION = "감독";

-- 강사님 
SELECT PERSON.PR_NAME, MOVIE.* FROM MOVIE 
JOIN MOVIE_ACTOR ON MA_MV_NUM = MV_NUM
JOIN ACTOR ON MA_AT_NUM = AT_NUM
JOIN PERSON ON AT_PR_NUM = PR_NUM
WHERE PR_NAME = "봉준호"; 


# 청소년들이 가장 많이 예매한 영화를 조회하는 쿼리
SELECT RANK() OVER(ORDER BY 청소년예매율 DESC) AS 순위, T.*
FROM ( 
SELECT MOVIE.*, SUM(TI_TEEN) 청소년예매수, SUM(TI_TEEN) * 100 / SUM(SUM(TI_TEEN)) OVER() AS 청소년예매율
FROM MOVIE
LEFT JOIN SCHEDULE ON SD_MV_NUM = MV_NUM 
LEFT JOIN TICKET ON SD_NUM = TI_SD_NUM
WHERE TI_STATE = '결제' AND CONCAT(SD_DATE," ",SD_TIME) >= NOW()
GROUP BY MV_NUM
) AS T
LIMIT 1;		 

-- 강사님
SELECT SUM(TI_TEEN) AS 예매수, MOVIE.* FROM TICKET 
RIGHT JOIN SCHEDULE ON SD_NUM = TI_SD_NUM -- 영화를 찾기 위해. 
RIGHT JOIN MOVIE ON SD_MV_NUM = MV_NUM 
WHERE TI_STATE = '결제' 
GROUP BY MV_NUM
ORDER BY 예매수 DESC
LIMIT 0,1; -- 0번지부터 하나. 사실 LIMIT 1이랑 같은건데 그냥 써보려고... 



